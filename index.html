<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setting Schedule Generator</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="app-container">
        <!-- SIDEBAR -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>Setting Schedule Generator</h1>
            </div>

            <div class="sidebar-actions">
                <!-- Primary Actions -->
                <button class="btn-primary full-width" id="generate-btn" disabled>
                    <span>Generate Schedules</span>
                </button>

                <button class="btn-secondary full-width" id="download-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    <span>Download Images</span>
                </button>

                <button class="btn-secondary full-width" id="print-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="6 9 6 2 18 2 18 9"></polyline>
                        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
                        <rect x="6" y="14" width="12" height="8"></rect>
                    </svg>
                    <span>Print / PDF</span>
                </button>

                <button class="btn-secondary full-width" id="email-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                        <polyline points="22,6 12,13 2,6"></polyline>
                    </svg>
                    <span>Email Schedule</span>
                </button>

                <div class="separator"></div>

                <!-- Utility Actions -->
                <button class="btn-utility full-width" id="save-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    <span>Save Latest</span>
                </button>

                <button class="btn-utility full-width" id="load-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <polyline points="1 20 1 14 7 14"></polyline>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                    </svg>
                    <span>Load Saved</span>
                </button>

                <button class="btn-utility full-width" id="settings-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path
                            d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51h.09a1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                        </path>
                    </svg>
                    <span>Email Settings</span>
                </button>

                <button class="btn-utility full-width" id="help-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                    <span>Instructions</span>
                </button>

                <div class="separator"></div>

                <button class="btn-utility full-width" id="theme-toggle-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <span id="theme-toggle-text">Dark Mode</span>
                </button>


                <button class="btn-utility full-width" id="clear-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                    <span>Clear All</span>
                </button>
            </div>
        </aside>

        <!-- MAIN CONTENT -->
        <main class="main-content">
            <!-- Initial Upload State (Will become compact, never hidden) -->
            <div class="upload-container" id="upload-container">
                <div class="upload-area" id="upload-area">
                    <div class="upload-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none"
                            stroke="#4db8a8" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                    </div>
                    <h2>Upload Humanity CSV(s)</h2>
                    <p>Drag & drop multiple files here or click to browse</p>
                    <input type="file" id="csv-input" accept=".csv" multiple style="display: none;">
                </div>
            </div>

            <!-- Toast Container (Fixed Position) -->
            <div id="messages"></div>

            <!-- Preview Area (Hidden initially) -->
            <div id="preview"></div>
        </main>
    </div>

    <script src="walls.js"></script>
    <script src="config.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            let csvData = []; // Changed to array to hold aggregated rows

            const appState = {
                schedules: {}, // Map: gymCode -> { scheduleByDay, dateRange, startDay }
                clickableRegions: [], // Stores regions for ALL canvases
                activeGyms: [] // List of gym codes that have data
            };

            const gymNameMap = {
                'DSN': 'Design',
                'PLN': 'Plano',
                'DTN': 'Denton',
                'FTW': 'Fort Worth',
                'GVN': 'Grapevine',
                'HIL': 'Dallas Hill'
            };

            // --- DOM ELEMENTS ---
            const uploadContainer = document.getElementById('upload-container'); // New
            const uploadArea = document.getElementById('upload-area');
            const csvInput = document.getElementById('csv-input');
            // const gymSelect = document.getElementById('gym-select'); // REMOVED

            const generateBtn = document.getElementById('generate-btn');
            const downloadBtn = document.getElementById('download-btn');
            const printBtn = document.getElementById('print-btn');
            const emailBtn = document.getElementById('email-btn');
            const saveBtn = document.getElementById('save-btn');
            const loadBtn = document.getElementById('load-btn');
            const clearBtn = document.getElementById('clear-btn'); // New

            const messages = document.getElementById('messages');
            const preview = document.getElementById('preview');

            const helpBtn = document.getElementById('help-btn');
            const modalOverlay = document.getElementById('help-modal-overlay');
            const modalCloseBtn = document.getElementById('modal-close-btn');

            const settingsBtn = document.getElementById('settings-btn');
            const settingsModalOverlay = document.getElementById('settings-modal-overlay');
            const settingsModalCloseBtn = document.getElementById('settings-modal-close-btn');
            const saveSettingsBtn = document.getElementById('save-settings-btn');
            const emailToInput = document.getElementById('email-to-input');
            const emailCcInput = document.getElementById('email-cc-input');
            const emailSubjectInput = document.getElementById('email-subject-input');
            const emailBodyInput = document.getElementById('email-body-input');

            const themeToggleBtn = document.getElementById('theme-toggle-btn');
            const themeToggleText = document.getElementById('theme-toggle-text');

            // --- DARK MODE FUNCTIONALITY ---
            // Check for saved theme preference or default to 'light'
            const currentTheme = localStorage.getItem('theme') || 'light';

            // Apply the theme on page load
            if (currentTheme === 'dark') {
                document.body.classList.add('dark-mode');
                updateThemeButton(true);
            }

            // Theme toggle function
            function toggleTheme() {
                document.body.classList.toggle('dark-mode');
                const isDark = document.body.classList.contains('dark-mode');

                // Save preference to localStorage
                localStorage.setItem('theme', isDark ? 'dark' : 'light');

                // Update button text and icon
                updateThemeButton(isDark);
            }

            // Update button text and icon based on theme
            function updateThemeButton(isDark) {
                if (isDark) {
                    themeToggleText.textContent = 'Light Mode';
                    // Change to sun icon for light mode
                    themeToggleBtn.querySelector('svg path').setAttribute('d', 'M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0z');
                } else {
                    themeToggleText.textContent = 'Dark Mode';
                    // Change to moon icon for dark mode
                    themeToggleBtn.querySelector('svg path').setAttribute('d', 'M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z');
                }
            }

            // Add click event listener
            themeToggleBtn.addEventListener('click', toggleTheme);


            // --- EVENT LISTENERS ---
            uploadArea.addEventListener('click', () => csvInput.click());
            uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
            uploadArea.addEventListener('dragleave', () => { uploadArea.classList.remove('dragover'); });
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                handleFiles(e.dataTransfer.files);
            });

            csvInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            // gymSelect listener REMOVED

            generateBtn.addEventListener('click', generateSchedules); // Renamed function
            downloadBtn.addEventListener('click', downloadImages);
            printBtn.addEventListener('click', () => window.print());

            helpBtn.addEventListener('click', () => { modalOverlay.style.display = 'block'; });
            modalCloseBtn.addEventListener('click', () => { modalOverlay.style.display = 'none'; });

            saveBtn.addEventListener('click', saveAllSchedules); // Renamed
            loadBtn.addEventListener('click', loadAllSchedules); // Renamed
            clearBtn.addEventListener('click', clearAll); // New

            emailBtn.addEventListener('click', generateAndOpenEmail);

            settingsBtn.addEventListener('click', () => {
                loadEmailSettings();
                settingsModalOverlay.style.display = 'block';
            });
            settingsModalCloseBtn.addEventListener('click', () => { settingsModalOverlay.style.display = 'none'; });
            saveSettingsBtn.addEventListener('click', saveEmailSettings);

            window.addEventListener('click', (event) => {
                if (event.target == modalOverlay) modalOverlay.style.display = 'none';
                if (event.target == settingsModalOverlay) settingsModalOverlay.style.display = 'none';
            });

            function handleFiles(files) {
                if (!files || files.length === 0) return;

                // --- CHANGE START: Reset data on new upload ---
                csvData = [];
                appState.activeGyms = []; // Optional: Clear active state so we don't mix old/new logic
                appState.schedules = {};
                // --- CHANGE END ---

                let processedCount = 0;
                const totalFiles = files.length;

                Array.from(files).forEach(file => {
                    if (!file.name.endsWith('.csv')) {
                        showMessage(`Skipped non-CSV file: ${file.name}`, 'error');
                        processedCount++;
                        if (processedCount === totalFiles) checkReady();
                        return;
                    }

                    Papa.parse(file, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            csvData = csvData.concat(results.data);
                            processedCount++;
                            if (processedCount === totalFiles) {
                                showMessage(`Loaded ${results.data.length} rows from ${file.name}. Total: ${csvData.length}`, 'info');
                                checkReady();

                                // Auto-generate immediately when done parsing
                                if (csvData.length > 0) {
                                    generateSchedules();
                                }
                            }
                        },
                        error: (error) => {
                            showMessage(`Error parsing ${file.name}: ${error.message}`, 'error');
                            processedCount++;
                            if (processedCount === totalFiles) checkReady();
                        }
                    });
                });
            }

            function checkReady() {
                generateBtn.disabled = !(csvData && csvData.length > 0);
            }

            // Updated showMessage to handle Toasts
            function showMessage(msg, type) {
                const toast = document.createElement('div');
                toast.className = `${type} toast-entry`;
                toast.textContent = msg;

                messages.appendChild(toast);

                // Auto-remove after 5 seconds
                setTimeout(() => {
                    toast.classList.add('fading-out');
                    // Wait for CSS transition to finish before removing from DOM
                    setTimeout(() => {
                        if (toast.parentNode) messages.removeChild(toast);
                    }, 300);
                }, 5000);
            }

            function initializeState() {
                appState.selectedGym = gymSelect.value;
                checkReady();
                updateLoadButtonState();
                loadEmailSettings();
            }

            function getWallType(walls, gym) {
                // --- IMPROVEMENT: Handle generic 'ropes' or 'boulders' text explicitly ---
                if (walls.includes('ropes')) return 'rope';
                if (walls.includes('boulders')) return 'boulder';

                if (walls.length === 0 || !gymWalls[gym]) return null;
                const firstWall = walls.find(w => gymWalls[gym][w]);
                return firstWall ? gymWalls[gym][firstWall]?.type : null;
            }

            function generateSchedules() {
                const generateUniqueId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);
                appState.schedules = {};
                appState.activeGyms = [];
                appState.clickableRegions = []; // Reset regions

                const gymCodes = Object.keys(gymNameMap);

                gymCodes.forEach(gymCode => {
                    // Filter data for this specific gym
                    const gymRows = csvData.filter(row => {
                        const location = (row['Location'] || '').trim();
                        return location.includes(gymNameMap[gymCode]);
                    });

                    if (gymRows.length === 0) return;

                    // Process data for this gym
                    const scheduleByDate = {};
                    gymRows.forEach(row => {
                        const date = row['Start Date'];
                        const title = (row['Title'] || '').toLowerCase();

                        const skipTitles = ['admin', 'personal training', 'washing', 'forerunning', 'climb time', '@hill', '@design', '@plano', '@dtn', '@ftw'];
                        if (skipTitles.some(skip => title.includes(skip))) return;

                        const names = (row['Employee Names'] || '').split('/').map(n => n.trim()).filter(n => n);
                        const setterCount = names.length;
                        if (setterCount === 0) return;

                        let walls = parseWalls(title, gymCode);
                        if (walls.length === 0) {
                            if (title.includes('rope')) walls = ['ropes'];
                            else if (title.includes('boulder')) walls = ['boulders'];
                            else return;
                        }

                        if (!scheduleByDate[date]) {
                            scheduleByDate[date] = { date: new Date(date), entries: [] };
                        }
                        scheduleByDate[date].entries.push({ walls: walls, setterCount: setterCount });
                    });

                    const allDates = Object.values(scheduleByDate).map(d => d.date).sort((a, b) => a - b);
                    if (allDates.length === 0) return;

                    // Calculate Date Range & Start Day
                    const gymConfig = templateCoords[gymCode];
                    const firstDate = allDates[0];
                    const startDay = new Date(firstDate);

                    if (gymConfig.weekStartDay === 'Monday') {
                        const dayOfWeek = startDay.getDay();
                        const adjustment = (dayOfWeek === 0) ? 6 : dayOfWeek - 1;
                        startDay.setDate(startDay.getDate() - adjustment);
                    } else {
                        startDay.setDate(startDay.getDate() - startDay.getDay());
                    }

                    const endDay = new Date(startDay);
                    if (gymConfig.weekStartDay === 'Monday') {
                        endDay.setDate(endDay.getDate() + 11);
                    } else {
                        endDay.setDate(endDay.getDate() + 13);
                    }

                    const dateRange = `${formatDate(startDay)}-${formatDate(endDay)}`;

                    // Build Schedule Array
                    const scheduleByDay = Array(14).fill(null).map(() => ({ routes: [], boulders: [] }));

                    Object.values(scheduleByDate).forEach(day => {
                        const daysSinceStart = Math.floor((day.date - startDay) / (1000 * 60 * 60 * 24));
                        if (daysSinceStart >= 0 && daysSinceStart < 14) {
                            day.entries.forEach(entry => {
                                const type = getWallType(entry.walls, gymCode);
                                if (!type) return;

                                const targetArray = (type === 'rope') ? scheduleByDay[daysSinceStart].routes : scheduleByDay[daysSinceStart].boulders;

                                targetArray.push({
                                    id: generateUniqueId(),
                                    walls: entry.walls,
                                    setterCount: entry.setterCount,
                                    climbType: type.charAt(0).toUpperCase() + type.slice(1)
                                });
                            });
                        }
                    });

                    // Store in App State
                    appState.schedules[gymCode] = {
                        scheduleByDay: scheduleByDay,
                        dateRange: dateRange,
                        startDay: startDay
                    };
                    appState.activeGyms.push(gymCode);
                });

                if (appState.activeGyms.length === 0) {
                    showMessage('No valid schedule data found for any gym.', 'error');
                } else {
                    renderApp();
                }
            } //end generateSchedule

            async function renderApp(silent = false) {
                // --- FIX START: Capture Scroll Positions ---
                // 1. Capture current height to prevent vertical collapse
                const previousHeight = preview.offsetHeight;
                if (previousHeight > 0) {
                    preview.style.minHeight = `${previousHeight}px`;
                }

                // 2. Capture scroll positions specifically
                // We need the window's vertical scroll (if user scrolled down to the section)
                const windowScrollY = window.scrollY;
                // We need the PREVIEW container's horizontal scroll (since it has overflow-x: auto)
                const previewScrollLeft = preview.scrollLeft;
                // --- FIX END ---

                preview.innerHTML = '';
                appState.clickableRegions = [];

                // Reset buttons
                downloadBtn.disabled = true;
                printBtn.disabled = true;
                saveBtn.disabled = true;
                emailBtn.disabled = true;

                if (appState.activeGyms.length === 0) {
                    // Reset to full size upload if no gyms
                    uploadContainer.classList.remove('compact');
                    preview.style.display = 'none';
                    preview.style.minHeight = '';
                    return;
                }

                // Compact the upload area, keep preview visible
                uploadContainer.classList.add('compact');
                preview.style.display = 'flex';

                window.generatedCanvases = []; // Reset global list for download

                for (const gymCode of appState.activeGyms) {
                    const gymData = appState.schedules[gymCode];
                    const gymName = gymNameMap[gymCode];

                    // Create Section for Gym
                    const section = document.createElement('div');
                    section.className = 'gym-section';

                    const header = document.createElement('div');
                    header.className = 'gym-header';
                    header.innerHTML = `<span class="gym-badge">${gymCode}</span> ${gymName}`;
                    section.appendChild(header);

                    const hasRoutes = gymData.scheduleByDay.some(day => day.routes.length > 0);
                    const hasBoulders = gymData.scheduleByDay.some(day => day.boulders.length > 0);

                    const canvases = await renderToCanvas(gymCode, gymData, hasRoutes, hasBoulders);
                    window.generatedCanvases = window.generatedCanvases.concat(canvases);

                    canvases.forEach(({
                        canvas
                    }) => {
                        canvas.dataset.gymCode = gymCode;
                        const wrapper = document.createElement('div');
                        wrapper.style.marginBottom = '20px';
                        canvas.style.maxWidth = '100%';
                        canvas.style.height = 'auto';
                        canvas.style.border = '1px solid #ddd';
                        wrapper.appendChild(canvas);
                        section.appendChild(wrapper);
                    });

                    preview.appendChild(section);
                }

                downloadBtn.disabled = false;
                printBtn.disabled = false;
                saveBtn.disabled = false;
                emailBtn.disabled = false;

                if (!silent) {
                    showMessage('Schedules generated successfully!', 'info');
                }

                // --- FIX START: Restore Scroll Positions ---
                // Remove the height lock so the container can resize naturally
                preview.style.minHeight = '';

                // Restore vertical scroll for the window
                window.scrollTo(0, windowScrollY);

                // Restore horizontal scroll for the container
                preview.scrollLeft = previewScrollLeft;
                // --- FIX END ---
            }

            async function renderToCanvas(gymCode, gymData, hasRoutes, hasBoulders) {
                const canvases = [];
                const { scheduleByDay, dateRange } = gymData;

                if (gymCode === 'GVN' || gymCode === 'PLN') {
                    if (hasRoutes || hasBoulders) {
                        const canvas = await renderPage(gymCode, 'routes', scheduleByDay, dateRange); // 'routes' template is actually combined for these
                        // Tag canvas type to match regions
                        canvas.dataset.canvasType = (gymCode === 'GVN') ? 'combined' : 'routes';
                        canvases.push({ canvas, name: `${gymCode}_schedule.png` });
                    }
                } else if (['HIL', 'DTN', 'FTW'].includes(gymCode)) {
                    if (hasBoulders) {
                        const canvas = await renderPage(gymCode, 'boulders', scheduleByDay, dateRange);
                        canvas.dataset.canvasType = 'boulders';
                        canvases.push({ canvas, name: `${gymCode}_boulders_schedule.png` });
                    }
                } else { // DSN and others with separate pages
                    if (hasRoutes) {
                        const canvas = await renderPage(gymCode, 'routes', scheduleByDay, dateRange);
                        canvas.dataset.canvasType = 'routes';
                        canvases.push({ canvas, name: `${gymCode}_routes_schedule.png` });
                    }
                    if (hasBoulders) {
                        const canvas = await renderPage(gymCode, 'boulders', scheduleByDay, dateRange);
                        canvas.dataset.canvasType = 'boulders';
                        canvases.push({ canvas, name: `${gymCode}_boulders_schedule.png` });
                    }
                }
                return canvases;
            }

            async function renderPage(gymCode, type, scheduleByDay, dateRange) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 791;
                    canvas.height = 1024;
                    const ctx = canvas.getContext('2d');

                    let templateFile;
                    if (gymCode === 'GVN') {
                        templateFile = `templates/${gymCode}_routes.png`;
                    } else if (['HIL', 'DTN', 'FTW'].includes(gymCode)) {
                        templateFile = `templates/${gymCode}_boulders.png`;
                    } else {
                        templateFile = `templates/${gymCode}_${type}.png`;
                    }

                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, 791, 1024);
                        const gymCoords = templateCoords[gymCode];
                        if (!gymCoords) { resolve(canvas); return; }

                        const coords = (gymCode === 'GVN' || gymCode === 'PLN') ? gymCoords['combined'] : gymCoords[type];
                        if (!coords) { resolve(canvas); return; }

                        if (coords.header) {
                            ctx.font = 'bold 24px Montserrat, Arial, sans-serif';
                            ctx.fillStyle = '#1e3a5f';
                            ctx.textAlign = 'right';
                            ctx.fillText(dateRange, coords.header.x, coords.header.y);
                            ctx.textAlign = 'left';
                        }

                        ctx.fillStyle = '#1e3a5f';
                        ctx.font = '14px Montserrat, Arial, sans-serif';
                        ctx.textBaseline = 'middle';

                        // Pass gymCode to renderTableData so it knows which config to use
                        renderTableData(ctx, scheduleByDay.slice(0, 7), type, coords.leftTable, coords.tableTop, coords.rowHeight, 0, gymCode);
                        renderTableData(ctx, scheduleByDay.slice(7, 14), type, coords.rightTable, coords.tableTop, coords.rowHeight, 7, gymCode);
                        resolve(canvas);
                    };
                    img.onerror = reject;
                    img.src = templateFile;
                });
            }

            function renderTableData(ctx, weekData, type, tableCoords, tableTop, rowHeight, weekOffset, gymCode) {
                const startDay = appState.schedules[gymCode].startDay;
                const gymConfig = templateCoords[gymCode];
                let currentY = tableTop;

                weekData.forEach((day, rowIndex) => {
                    const dayIndex = weekOffset + rowIndex;
                    const currentDate = new Date(startDay);
                    currentDate.setDate(currentDate.getDate() + dayIndex);
                    const dateStr = formatDate(currentDate);
                    const dayOfWeek = currentDate.getDay();

                    if (gymConfig.displayMode === 'separate' && (dayOfWeek === 0 || dayOfWeek === 6)) {
                        return;
                    }

                    const hasRoutes = day.routes && day.routes.length > 0;
                    const hasBoulders = day.boulders && day.boulders.length > 0;

                    let itemsForDay = [];
                    if (gymConfig.combined) {
                        itemsForDay = (day.routes || []).concat(day.boulders || []);
                    } else {
                        if (type === 'routes') itemsForDay = day.routes || [];
                        else if (type === 'boulders') itemsForDay = day.boulders || [];
                        else itemsForDay = (day.routes || []).concat(day.boulders || []);
                    }

                    // --- SEPARATE DISPLAY MODE (e.g., Grapevine Weekdays) ---
                    if (gymConfig.displayMode === 'separate') {
                        if (!hasRoutes && !hasBoulders) {
                            const textY = currentY - (rowHeight / 2);
                            ctx.fillText(dateStr, tableCoords.date.x, currentY);
                            ctx.fillText('---', tableCoords.location.x, currentY);
                            ctx.fillText('---', tableCoords.climbType.x, currentY);
                            ctx.fillText('---', tableCoords.setters.x, currentY);
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'routes', field: 'location', value: '---', x: tableCoords.location.x, y: textY, width: tableCoords.location.width, height: rowHeight, canvasType: 'combined', id: null });
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'routes', field: 'climbType', value: '---', x: tableCoords.climbType.x, y: textY, width: tableCoords.climbType.width, height: rowHeight, canvasType: 'combined', id: null });
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'routes', field: 'setterCount', value: '---', x: tableCoords.setters.x, y: textY, width: tableCoords.setters.width, height: rowHeight, canvasType: 'combined', id: null });
                            currentY += rowHeight;
                            return;
                        }

                        let dateDrawn = false;

                        if (hasRoutes) {
                            const routeTextY = currentY - (rowHeight / 2);
                            const firstRoute = day.routes[0];
                            const locationText = capitalizeWallNames(day.routes.map(i => i.walls.join(', ')).join(', '));
                            const setterCountText = String(day.routes.reduce((total, item) => total + item.setterCount, 0));

                            ctx.fillText(dateStr, tableCoords.date.x, currentY);
                            ctx.fillText(truncateText(ctx, locationText, tableCoords.location.width), tableCoords.location.x, currentY);
                            // --- FIX: Use the stored climbType from the first route entry ---
                            ctx.fillText(firstRoute.climbType, tableCoords.climbType.x, currentY);
                            ctx.fillText(setterCountText, tableCoords.setters.x, currentY);

                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'routes', field: 'location', value: locationText, x: tableCoords.location.x, y: routeTextY, width: tableCoords.location.width, height: rowHeight, canvasType: 'combined', id: firstRoute.id });
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'routes', field: 'climbType', value: firstRoute.climbType, x: tableCoords.climbType.x, y: routeTextY, width: tableCoords.climbType.width, height: rowHeight, canvasType: 'combined', id: firstRoute.id });
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'routes', field: 'setterCount', value: setterCountText, x: tableCoords.setters.x, y: routeTextY, width: tableCoords.setters.width, height: rowHeight, canvasType: 'combined', id: firstRoute.id });

                            currentY += rowHeight;
                            dateDrawn = true;
                        }

                        if (hasBoulders) {
                            const boulderTextY = currentY - (rowHeight / 2);
                            const firstBoulder = day.boulders[0];
                            const locationText = capitalizeWallNames(day.boulders.map(i => i.walls.join(', ')).join(', '));
                            const setterCountText = String(day.boulders.reduce((total, item) => total + item.setterCount, 0));

                            if (!dateDrawn) {
                                ctx.fillText(dateStr, tableCoords.date.x, currentY);
                            }
                            ctx.fillText(truncateText(ctx, locationText, tableCoords.location.width), tableCoords.location.x, currentY);
                            // --- FIX: Use the stored climbType from the first boulder entry ---
                            ctx.fillText(firstBoulder.climbType, tableCoords.climbType.x, currentY);
                            ctx.fillText(setterCountText, tableCoords.setters.x, currentY);

                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'boulders', field: 'location', value: locationText, x: tableCoords.location.x, y: boulderTextY, width: tableCoords.location.width, height: rowHeight, canvasType: 'combined', id: firstBoulder.id });
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'boulders', field: 'climbType', value: firstBoulder.climbType, x: tableCoords.climbType.x, y: boulderTextY, width: tableCoords.climbType.width, height: rowHeight, canvasType: 'combined', id: firstBoulder.id });
                            appState.clickableRegions.push({ gymCode, dayIndex, dataType: 'boulders', field: 'setterCount', value: setterCountText, x: tableCoords.setters.x, y: boulderTextY, width: tableCoords.setters.width, height: rowHeight, canvasType: 'combined', id: firstBoulder.id });

                            currentY += rowHeight;
                        }

                    } else { // --- MERGED DISPLAY MODE (All other gyms, including weekends) ---
                        const textY = currentY - (rowHeight / 2);
                        let climbTypeText = '---';
                        if (itemsForDay.length > 0) {
                            if (hasRoutes && hasBoulders) {
                                climbTypeText = 'Both';
                            } else {
                                climbTypeText = itemsForDay[0].climbType;
                            }
                        }

                        const locationText = itemsForDay.length > 0 ? capitalizeWallNames(itemsForDay.map(i => i.walls.join(', ')).join(', ')) : '---';
                        const setterCountText = itemsForDay.length > 0 ? String(itemsForDay.reduce((total, item) => total + item.setterCount, 0)) : '---';

                        ctx.fillText(dateStr, tableCoords.date.x, currentY);
                        ctx.fillText(truncateText(ctx, locationText, tableCoords.location.width), tableCoords.location.x, currentY);
                        ctx.fillText(climbTypeText, tableCoords.climbType.x, currentY);
                        ctx.fillText(setterCountText, tableCoords.setters.x, currentY);

                        const firstItem = itemsForDay.length > 0 ? itemsForDay[0] : null;
                        const firstItemId = firstItem ? firstItem.id : null;
                        const actualClimbType = firstItem ? firstItem.climbType : '---';

                        appState.clickableRegions.push({ gymCode, dayIndex, dataType: type, field: 'location', value: locationText, x: tableCoords.location.x, y: textY, width: tableCoords.location.width, height: rowHeight, canvasType: type, id: firstItemId });
                        appState.clickableRegions.push({ gymCode, dayIndex, dataType: type, field: 'climbType', value: actualClimbType, x: tableCoords.climbType.x, y: textY, width: tableCoords.climbType.width, height: rowHeight, canvasType: type, id: firstItemId });
                        appState.clickableRegions.push({ gymCode, dayIndex, dataType: type, field: 'setterCount', value: setterCountText, x: tableCoords.setters.x, y: textY, width: tableCoords.setters.width, height: rowHeight, canvasType: type, id: firstItemId });

                        currentY += rowHeight;
                    }
                });
            }

            preview.addEventListener('click', function (e) {
                // Only proceed if the click is on a canvas and no editor is active
                if (document.getElementById('canvas-editor') || e.target.tagName !== 'CANVAS') return;

                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();

                // Calculate scale factors to match click to canvas resolution
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                const clickedGymCode = canvas.dataset.gymCode;
                const clickedCanvasType = canvas.dataset.canvasType; // NEW: Get the canvas type

                for (const region of appState.clickableRegions) {
                    if (region.gymCode !== clickedGymCode) continue;
                    // NEW: Ensure we only trigger regions that belong to this canvas
                    if (region.canvasType !== clickedCanvasType) continue;

                    // Check if click is within the region's bounding box
                    if (x > region.x && x < region.x + region.width && y > region.y && y < region.y + region.height) {
                        showEditor(region, canvas);
                        return;
                    }
                }
            });

            function showEditor(region, canvas) {
                let editorElement;
                // --- CHANGE: The full list of user-selectable options ---
                const climbTypeOptions = ['Rope', 'Boulder', 'Slab', 'Vert', 'Overhang', 'Steep'];

                if (region.field === 'climbType') {
                    editorElement = document.createElement('select');

                    // Add a special disabled "Both" option if it's currently displayed
                    if (region.value === 'Both' || (appState.schedules[region.gymCode].scheduleByDay[region.dayIndex].routes.length > 0 && appState.schedules[region.gymCode].scheduleByDay[region.dayIndex].boulders.length > 0)) {
                        const bothOption = document.createElement('option');
                        bothOption.value = "Both";
                        bothOption.textContent = "Both (Automatic)";
                        bothOption.disabled = true;
                        bothOption.selected = true;
                        editorElement.appendChild(bothOption);
                    }

                    climbTypeOptions.forEach(optionText => {
                        const option = document.createElement('option');
                        option.value = optionText;
                        option.textContent = optionText;
                        if (optionText === region.value) option.selected = true;
                        editorElement.appendChild(option);
                    });
                } else {
                    editorElement = document.createElement('input');
                    editorElement.type = region.field === 'setterCount' ? 'number' : 'text';
                    editorElement.value = region.value === '-' ? '' : region.value;
                }

                // ... (the rest of the function remains the same) ...
                editorElement.id = 'canvas-editor';
                const canvasRect = canvas.getBoundingClientRect();
                const scaleX = canvasRect.width / canvas.width;
                const scaleY = canvasRect.height / canvas.height;
                document.body.appendChild(editorElement);
                editorElement.style.position = 'absolute';
                editorElement.style.left = `${window.scrollX + canvasRect.left + (region.x * scaleX)}px`;
                editorElement.style.top = `${window.scrollY + canvasRect.top + (region.y * scaleY)}px`;
                editorElement.style.width = `${region.width * scaleX}px`;
                editorElement.style.height = `${region.height * scaleY}px`;
                editorElement.style.font = `${14 * scaleY}px Montserrat, Arial, sans-serif`;
                editorElement.style.border = '2px solid #4db8a8';
                editorElement.style.boxSizing = 'border-box';
                editorElement.focus();
                if (editorElement.tagName === 'INPUT') editorElement.select();

                const handleUpdate = () => {
                    updateScheduleData(region, editorElement.value);
                    if (editorElement.parentNode) document.body.removeChild(editorElement);
                };

                editorElement.addEventListener('blur', handleUpdate, { once: true });
                editorElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') editorElement.blur();
                    else if (e.key === 'Escape') if (editorElement.parentNode) document.body.removeChild(editorElement);
                });
                if (editorElement.tagName === 'SELECT') editorElement.addEventListener('change', handleUpdate, { once: true });
            }

            async function updateScheduleData(region, newValue) {
                if (newValue === region.value) return;

                const gymData = appState.schedules[region.gymCode];
                const dayData = gymData.scheduleByDay[region.dayIndex];
                let itemToUpdate = null;
                let sourceArray = null;

                if (region.gymCode === 'GVN' || region.gymCode === 'PLN') {
                    itemToUpdate = dayData.routes.find(item => item.id === region.id);
                    if (itemToUpdate) sourceArray = dayData.routes;
                    else {
                        itemToUpdate = dayData.boulders.find(item => item.id === region.id);
                        if (itemToUpdate) sourceArray = dayData.boulders;
                    }
                } else {
                    sourceArray = dayData[region.dataType];
                    if (sourceArray) itemToUpdate = sourceArray.find(item => item.id === region.id);
                }

                if (itemToUpdate) { // Logic for updating an EXISTING item
                    if (region.field === 'location') {
                        if (!newValue) {
                            const updatedArray = sourceArray.filter(item => item.id !== region.id);
                            if (dayData.routes === sourceArray) dayData.routes = updatedArray;
                            else dayData.boulders = updatedArray;
                        } else {
                            itemToUpdate.walls = newValue.split(',').map(w => w.trim());
                        }
                    } else if (region.field === 'setterCount') {
                        itemToUpdate.setterCount = parseInt(newValue, 10) || 0;
                    } else { // This handles climbType
                        itemToUpdate[region.field] = newValue;
                    }

                } else if (newValue && newValue !== '-' && newValue !== '0') { // Logic for creating a NEW item
                    const newEntry = {
                        id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                        // Use the startDay from the specific gym's schedule
                        date: new Date(gymData.startDay.getTime() + region.dayIndex * 24 * 60 * 60 * 1000),
                        walls: ['New Set'],
                        climbType: 'Sport', // A sensible default
                        setterCount: 1
                    };

                    if (region.field === 'setterCount') {
                        newEntry.setterCount = parseInt(newValue, 10) || 1;
                    } else if (region.field === 'location') {
                        newEntry.walls = newValue.split(',').map(w => w.trim());
                    } else if (region.field === 'climbType') {
                        newEntry.climbType = newValue;
                    }

                    dayData[region.dataType].push(newEntry);
                }

                await renderApp(true);
            }

            function saveAllSchedules() {
                if (appState.activeGyms.length === 0) {
                    showMessage('Nothing generated to save.', 'error');
                    return;
                }

                let savedCount = 0;
                appState.activeGyms.forEach(gymCode => {
                    const key = `latest_schedule_${gymCode}`;
                    const data = appState.schedules[gymCode];
                    const dataToSave = {
                        scheduleByDay: data.scheduleByDay,
                        dateRange: data.dateRange,
                        startDay: data.startDay.toISOString()
                    };
                    localStorage.setItem(key, JSON.stringify(dataToSave));
                    savedCount++;
                });

                showMessage(`Saved schedules for ${savedCount} gym(s) to this browser!`, 'info');
            }

            function loadAllSchedules() {
                const gymCodes = Object.keys(gymNameMap);
                let loadedCount = 0;

                appState.schedules = {};
                appState.activeGyms = [];

                gymCodes.forEach(gymCode => {
                    const key = `latest_schedule_${gymCode}`;
                    const savedData = localStorage.getItem(key);
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        appState.schedules[gymCode] = {
                            scheduleByDay: parsedData.scheduleByDay,
                            dateRange: parsedData.dateRange,
                            startDay: new Date(parsedData.startDay)
                        };
                        appState.activeGyms.push(gymCode);
                        loadedCount++;
                    }
                });

                if (loadedCount > 0) {
                    renderApp();
                    showMessage(`Loaded saved schedules for ${loadedCount} gym(s).`, 'info');
                } else {
                    showMessage('No saved schedules found.', 'info');
                }
            }

            function clearAll() {
                if (confirm('Are you sure you want to clear all generated schedules?')) {
                    appState.schedules = {};
                    appState.activeGyms = [];
                    appState.clickableRegions = [];
                    csvData = [];
                    renderApp(); // This will trigger the empty state logic
                    showMessage('All cleared.', 'info');
                }
            }

            function expandWallRanges(titleStr) {
                const namedRangeRegex = /([a-zA-Z]+)(\d+)-([a-zA-Z]+)(\d+)/g;
                const simpleRangeRegex = /([a-zA-Z]+)(\d+)-(\d+)/g;
                let expandedStr = titleStr;
                expandedStr = expandedStr.replace(namedRangeRegex, (match, prefix1, startStr, prefix2, endStr) => {
                    if (prefix1 !== prefix2) return match;
                    const start = parseInt(startStr);
                    const end = parseInt(endStr);
                    const min = Math.min(start, end);
                    const max = Math.max(start, end);
                    const expanded = [];
                    for (let i = min; i <= max; i++) expanded.push(prefix1 + i);
                    return expanded.join(', ');
                });
                expandedStr = expandedStr.replace(simpleRangeRegex, (match, prefix, startStr, endStr) => {
                    const start = parseInt(startStr);
                    const end = parseInt(endStr);
                    const expanded = [];
                    for (let i = start; i <= end; i++) expanded.push(prefix + i);
                    return expanded.join(', ');
                });
                return expandedStr;
            }

            // --- NEW: Function to generate and open the pre-filled email draft ---
            function generateAndOpenEmail() {
                // Check if we have any active schedules
                if (appState.activeGyms.length === 0) {
                    showMessage('Please generate a schedule before emailing.', 'error');
                    return;
                }

                // 1. Get saved templates, with sensible defaults
                const to = localStorage.getItem('emailConfig_to') || '';
                const cc = localStorage.getItem('emailConfig_cc') || '';
                const subjectTemplate = localStorage.getItem('emailConfig_subject') || '[GYM_NAME] Setting Schedule: [DATE_RANGE]';
                const bodyTemplate = localStorage.getItem('emailConfig_body') || `Hi Team,\n\nPlease find the setting schedule for [GYM_NAME] for the weeks of [DATE_RANGE].\n\n(Please remember to attach the schedule image to this email before sending.)\n\nThanks!`;

                // 2. Build gym names and date range from active gyms
                let gymNames = [];
                let dateRanges = [];

                appState.activeGyms.forEach(gymCode => {
                    const gymData = appState.schedules[gymCode];
                    if (gymData) {
                        gymNames.push(gymNameMap[gymCode] || gymCode);
                        dateRanges.push(gymData.dateRange);
                    }
                });

                // Create combined strings for multiple gyms
                const gymFullName = gymNames.length > 1
                    ? gymNames.join(', ')
                    : (gymNames[0] || 'All Gyms');

                // Use the first date range (they should all be the same for a combined schedule)
                const dateRange = dateRanges[0] || '';

                // 3. Replace placeholders with actual data
                const subject = subjectTemplate
                    .replace('[GYM_NAME]', gymFullName)
                    .replace('[DATE_RANGE]', dateRange);
                const body = bodyTemplate
                    .replace('[GYM_NAME]', gymFullName)
                    .replace('[DATE_RANGE]', dateRange);

                // 4. Construct the mailto link, ensuring components are URL-encoded
                let mailtoLink = `mailto:${encodeURIComponent(to)}`;
                mailtoLink += `?subject=${encodeURIComponent(subject)}`;
                if (cc) mailtoLink += `&cc=${encodeURIComponent(cc)}`;
                mailtoLink += `&body=${encodeURIComponent(body)}`;

                // 5. Trigger the user's email client
                window.location.href = mailtoLink;
            }

            // --- NEW: Functions to save and load email settings from localStorage ---
            function saveEmailSettings() {
                localStorage.setItem('emailConfig_to', emailToInput.value);
                localStorage.setItem('emailConfig_cc', emailCcInput.value);
                localStorage.setItem('emailConfig_subject', emailSubjectInput.value);
                localStorage.setItem('emailConfig_body', emailBodyInput.value);

                showMessage('Email settings saved successfully!', 'info');
                settingsModalOverlay.style.display = 'none';
            }

            function loadEmailSettings() {
                emailToInput.value = localStorage.getItem('emailConfig_to') || 'Shelbi.Kirbow@movementgyms.com';
                emailCcInput.value = localStorage.getItem('emailConfig_cc') || 'Nolan.Black@MovementGyms.com, GymDirector@MovementGyms.com, AssistantGymDirector@MovementGyms.com';
                emailSubjectInput.value = localStorage.getItem('emailConfig_subject') || '[GYM_NAME] Setting Schedule: [DATE_RANGE]';
                emailBodyInput.value = localStorage.getItem('emailConfig_body') || `Hi Team,\n\nPlease find the setting schedule for [GYM_NAME] for the weeks of [DATE_RANGE].\n\n(Please remember to attach the schedule image to this email before sending.)\n\nThanks!`;
            }

            function parseWalls(titleStr, gym) {
                if (!titleStr || !gymWalls[gym]) return [];
                const currentGymWalls = gymWalls[gym];
                const expandedTitle = expandWallRanges(titleStr);
                let cleanTitle = expandedTitle.toLowerCase().replace('jcca - ', '');
                const parts = cleanTitle.replace(/\./g, '').split(/[,\/\s+]+/g).filter(s => s);
                const walls = [];
                let buffer = [];
                for (const part of parts) {
                    buffer.push(part);
                    const potentialWall = buffer.join(' ');
                    if (currentGymWalls[potentialWall]) {
                        walls.push(potentialWall);
                        buffer = [];
                    }
                }
                for (const part of buffer) {
                    if (currentGymWalls[part]) walls.push(part);
                }
                return [...new Set(walls)];
            }

            function formatDate(date) {
                const d = new Date(date);
                const month = d.getMonth() + 1;
                const day = d.getDate();
                return `${month}/${day}`;
            }

            function getWallAngle(walls, gym) {
                if (walls.length === 0 || !gymWalls[gym]) return 'Slab'; // Default
                const firstWall = walls.find(w => gymWalls[gym][w]);
                // --- Look for the 'climb_type' property in your gymWalls object ---
                return firstWall ? gymWalls[gym][firstWall]?.climb_type || 'Slab' : 'Slab';
            }

            function truncateText(ctx, text, maxWidth) {
                if (ctx.measureText(text).width <= maxWidth) return text;
                let truncated = text;
                while (ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                    truncated = truncated.slice(0, -1);
                }
                return truncated + '...';
            }

            function capitalizeWallNames(text) {
                if (!text) return '';
                return text.split(', ').map(wallName => {
                    return wallName.split(' ').map(word => {
                        return word.charAt(0).toUpperCase() + word.slice(1);
                    }).join(' ');
                }).join(', ');
            }

            function downloadImages() {
                if (!window.generatedCanvases || window.generatedCanvases.length === 0) {
                    showMessage('No schedules to download.', 'error');
                    return;
                }

                // Add a delay between downloads to prevent browser blocking
                let delay = 0;
                window.generatedCanvases.forEach(({ canvas, name }, index) => {
                    setTimeout(() => {
                        canvas.toBlob((blob) => {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = name;
                            a.click();
                            URL.revokeObjectURL(url);
                        });
                    }, delay);
                    delay += 200; // 200ms delay between each download
                });

                showMessage(`Downloading ${window.generatedCanvases.length} schedule image(s)...`, 'info');
            }

            function initializeState() {
                loadEmailSettings();

                // Check if any saved schedules exist to enable/disable Load button
                const gymCodes = Object.keys(gymNameMap);
                let hasSaved = false;
                for (const code of gymCodes) {
                    if (localStorage.getItem(`latest_schedule_${code}`)) {
                        hasSaved = true;
                        break;
                    }
                }
                // loadBtn is not disabled by default in HTML, but we can manage it if we want.
                // For now, let's just leave it enabled or handle it if we want strict behavior.
                // If we want to disable it if nothing is saved:
                // loadBtn.disabled = !hasSaved; 
            }

            initializeState();
        });
    </script>
    <!-- ======================= -->
    <!--     INSTRUCTIONS MODAL    -->
    <!-- ======================= -->
    <div id="help-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <span id="modal-close-btn" class="modal-close">&times;</span>
            <h2>How to Use the Schedule Generator</h2>

            <div class="help-section quick-start">
                <h4>Quick Start Workflow</h4>
                <ol>
                    <li>
                        <strong>Upload CSV(s):</strong>
                        <span>Drag & drop one or more Humanity CSV files into the upload area. The
                            app automatically detects all gyms in your files!</span>
                    </li>
                    <li>
                        <strong>Auto-Generation:</strong>
                        <span>Schedules for all detected gyms are generated instantlyno manual gym
                            selection needed.</span>
                    </li>
                    <li>
                        <strong>Interactive Editing:</strong>
                        <span>Click any field (location, climb type, setter count) to edit
                            in-place. Press <code>Enter</code> to save.</span>
                    </li>
                    <li>
                        <strong>Export:</strong>
                        <span>Download images, print to PDF, or email schedules using the sidebar
                            buttons.</span>
                    </li>
                </ol>
            </div>

            <div class="help-section save-load">
                <h4>Saving & Loading Schedules</h4>
                <ul>
                    <li>
                        <strong>Save as Latest:</strong>
                        <span>Stores all current schedules to your browser's local storage.</span>
                    </li>
                    <li>
                        <strong>Load Latest:</strong>
                        <span>Instantly restore your previously saved schedules (button activates
                            when saved data exists).</span>
                    </li>
                    <li>
                        <strong>Clear All:</strong>
                        <span>Remove all schedules from view and start fresh.</span>
                    </li>
                </ul>
            </div>

            <div class="help-section email-integration">
                <h4>Email Integration</h4>
                <p>
                    Configure your email template in <strong>Settings</strong>, then click <strong>Email
                        Schedule</strong> to auto-populate a draft email with:
                </p>
                <ul>
                    <li>Pre-filled recipients, subject, and message body</li>
                    <li>Note: You'll need to manually attach the downloaded schedule images</li>
                </ul>
            </div>

            <div class="tip-box">
                <p>
                    <strong>Tip:</strong> Upload a combined CSV with multiple gyms to generate all schedules at
                    once. Each gym's schedule appears in its own section with a color-coded badge.
                </p>
            </div>

            <p class="note-footer">
                <strong>Note:</strong> Saved schedules are stored locally in your browser, not in the cloud. They're
                only accessible on this device and browser.
            </p>
        </div>
    </div>
    <!-- ======================= -->
    <!--     SETTINGS MODAL        -->
    <!-- ======================= -->
    <div id="settings-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <span id="settings-modal-close-btn" class="modal-close">&times;</span>
            <h2>Email Settings</h2>
            <p>Configure the default email template. These settings will be saved in your browser.</p>

            <div class="settings-form">
                <div class="control-group">
                    <label for="email-to-input">To (separate emails with a comma)</label>
                    <textarea id="email-to-input" rows="2"></textarea>
                </div>
                <div class="control-group">
                    <label for="email-cc-input">CC (separate emails with a comma)</label>
                    <textarea id="email-cc-input" rows="2"></textarea>
                </div>
                <div class="control-group">
                    <label for="email-subject-input">Subject Template</label>
                    <input type="text" id="email-subject-input">
                    <small class="template-hint">Use <strong>[GYM_NAME]</strong> and <strong>[DATE_RANGE]</strong> as
                        placeholders.</small>
                </div>
                <div class="control-group">
                    <label for="email-body-input">Body Template</label>
                    <textarea id="email-body-input" rows="6"></textarea>
                    <small class="template-hint">Use <strong>[GYM_NAME]</strong> and <strong>[DATE_RANGE]</strong>. The
                        user must manually attach the schedule image.</small>
                </div>
            </div>

            <div class="modal-buttons">
                <button class="btn-primary" id="save-settings-btn">Save Settings</button>
            </div>
        </div>
    </div>
</body>

</html>